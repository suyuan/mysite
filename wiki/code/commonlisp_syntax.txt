Common Lisp语法


特殊符号

'：操作符 quote 的别名，用以保护表达式不被求值，常用写法为 '(+ 1 2)
#'：操作符 function 的别名，返回目标函数所对应的对象，如 #'+
t：逻辑真
nil：逻辑假


数据类型

符号：一般需要要 ' 进行引用，如 'Ruchee
列表：用括号包裹的零个或多个元素，元素不限类型，可以通过调用 list 函数来构建，空列表可用 () 或 nil 来表示
数值有类型，变量无类型，t 是所有类型的基类，每个对象都属于 t 类型
数字的七种类型：fixnum、integer、rational、real、number、atom、t
数组：使用 make-array 生成，第一个参数传递数值则生成一维数组，第一个参数传递列表则生成多维数组；使用 aref 取数组元素的引用，可以结合 setf 实现对数组元素的赋值和修改
向量：一维数组也称为向量，可以使用 vector 生成。存取向量元素不仅可以用 aref，还可以用速度更快的向量专用函数 svref。向量可以用 #() 语法表示
字符：表示方法为一个#号加一个斜杠，再加字符本身，如 #\A


变量与赋值

定义全局变量：(defparameter 全局变量名)，其中全局变量名习惯以 * 号包裹
定义全局常量：(defconstant 全局常量名)
创建局部变量：(let ((变量名1 变量值1) (变量名2 变量值2) ... ) 局部变量作用域)
变量赋值：(setf 变量名1 变量值1 变量名2 变量值2 ...)，如果 setf 的第一个实参是符号，且符号不是某个局部变量名，则 setf 会把这个符号设为全局变量
变量的赋值本质都只是指针的运算，只是不像 C/C++ 一样有显式的指针


流程控制

if：(if (测试条件) (满足执行) (不满足执行))，第三个参数可选
do：(do (基准条件) 迭代体)，其中基准条件中可以定义局部变量，基本格式为(变量名 初始值 每一次迭代后的值)
dolist：(dolist (单个元素 整个列表) 迭代体)


函数

基本形式：(defun 函数名 (参数表列) 函数体)
匿名函数：(lambda (参数表列) 函数体)


工具函数

progn：接受任意数量的表达式，依序对它们求值，并返回最后一个表达式的值
apply：接受一个函数对象和任意个参数，然后使用这些参数调用该函数，最后一个参数必须是列表
funcall：与 apply 作用相同，但参数不能是列表，必须是一个个单个的值
cons：创建列表，与 list 的区别在于，cons 创建的是点对表，而 list 创建的只是单纯的表
car：返回列表的第一个元素
cdr：返回列表除第一个元素以外的所有元素
cxr：其中 x 由连续的最多四个 a 或 d 组成，表达 cxr of cxr of ... 的意思，如 cadr 意思是 car of cdr，(cadr x) 等同于 (car (cdr x))
copy-list：拷贝一个列表，而不是默认的指针指向
append：串接列表
nth：取特定索引的元素
nthcdr：取特定索引的 cdr，nth 和 nthcdr 都从 0 开始索引
last：返回最后一个 cons 对象（和取最后一个元素不一样，取最后一个元素需要取 last 的 car）
first - tenth：取得特定索引的元素，从 1 开始索引，而不是 0
length：返回序列元素的个数
subseq：截取序列，第一个参数是接收序列，第二个参数指定截取起始位置，可选的第三个参数指定截取终止位置
reverse：翻转列表
sort：接受一个序列和一个函数，对序列元素使用该函数进行比较排序。需要注意的是，本函数会同时修改序列原有的值，具有破坏性
every、some：接受一个函数以及和该函数所需参数一样多的列表，然后每次取出各列表相对应的一组元素调用该函数，直到所有元素调用完返回最终的判断结果
push：向列表最前面压入元素
pop：从列表最末尾弹出元素
pushnew：只有当元素不存在时才压入
mapcar：接受一个函数和任意个列表，每次取出各个列表相同位置的元素一起应用与该函数，直到其中任意一个列表的元素应用完为止
maplist：参数和 mapcar 一样，只是每次取出的不是单个的元素，而是一个个渐进减少的 cdr，如 (1 2 3) 将被依次取出 (1 2 3)、(2 3)、(3)
member：在一个列表中寻找指定元素，返回该元素第一次匹配直到列表结束的所有内容，默认使用 eql 来比较，可使用 :test 关键字参数自定义比较函数
member-if、member-if-not：当没有特定的搜索元素时，这两者可提供一个模糊搜索功能，通过向其传递一个函数，寻找譬如 奇数、偶数 等
assoc：根据键名从关联数组取键值
assoc-if、assoc-if-not：模糊查找键名
adjoin：一个条件版的 cons，其接受一个对象和一个列表，只有该对象不存在于该列表，才将对象构建到列表里面
intersection（交）、union（并）、set-difference（补）：三函数均接受两个列表，进行集合求并、求交、求补的操作
remove：接受一个对象和一个列表，返回一个不含该对象的新列表
substitute：替换列表顶层元素，形式为 (substitute 新值 旧值 目标列表)，如 (substitute 'y 'x '(x y (x y))) => (y y (x y))
subst：替换全部元素，包括嵌套层，如 (subst 'y 'x '(x y (x y))) => (y y (y y))


判断函数

null：是否为空
not：逻辑值取反（尽管意义不一样，但在效果上 null 和 not 是一样的）
integerp：是否是整数
oddp：是否是奇数
evenp：是否是偶数
zerop：是否是0
atom：是否是原子
listp：是否是列表
consp：是否是 cons 对象
boundp：是否为全局变量或常量
typep：是否属于某类型，如 (typep 3 'integer)
eql：是否是相同的对象
equal：是否拥有相同的值，比 eql 宽松


输入输出

format 格式化输出

~{、~}：循环格式化一个列表，这两个符号代表格式化列表的开始和结束
~a：美化输出
~t：制表符，~3t 代表后移 3 列
~%：输出换行

一个 format 函数的使用示例如下：
(defun dump-db ()
 (dolist (cd *db*)
  (format t "~{~a:~3t~a~%~}~%" cd)))

read 获取输入


编码惯例

返回值为逻辑真或逻辑假的函数，通常函数名以 p 结尾
列表必须被引用，不然会被视作代码；符号必须被引用，不然会被视作变量
nil 既是原子，也是列表
全局变量名用 * 号包裹
对递归函数的理解不要向命令式语言一样一层层去追，而应该用数学归纳法的思想，只要覆盖了全部的情况就可以认为递归函数写对了


2013-07-30 08:06
2013-08-02 14:46
